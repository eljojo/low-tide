<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Low Tide</title>
<style>
  :root {
    --bg: #041b26;
    --fg: #fef4e3;
    --accent: #ff7f1f;
    --accent2: #00c0a3;
    --muted: #5c6f82;
    --card-bg: #0c2835;
    --danger: #ff4b5c;
  }
  * { box-sizing: border-box; }
  body {
    margin: 0;
    font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    background: var(--bg);
    color: var(--fg);
    display: flex;
    flex-direction: column;
    min-height: 100vh;
  }
  header {
    padding: 1rem 1.5rem;
    background: linear-gradient(90deg, #ff7f1f, #ffca1f);
    color: #041b26;
    font-weight: 800;
    letter-spacing: 0.06em;
    text-transform: uppercase;
    display: flex;
    align-items: center;
    gap: 0.75rem;
    box-shadow: 0 0 20px rgba(255, 127, 31, 0.4);
  }
  header .blob {
    width: 32px;
    height: 32px;
    background: #041b26;
    border-radius: 60% 40% 40% 70% / 50% 60% 40% 50%;
  }
  main {
    flex: 1;
    padding: 1.5rem;
    max-width: 1400px;
    margin: 0 auto;
    display: grid;
    grid-template-columns: 1fr 2fr;
    gap: 1.2rem;
    align-items: start;
    width: 80%;
  }
  .card {
    background: var(--card-bg);
    border-radius: 14px;
    padding: 1rem 1.2rem;
    box-shadow: 0 0 0 1px rgba(255,255,255,0.02), 0 14px 30px rgba(0,0,0,0.45);
  }
  h2 {
    font-size: 0.95rem;
    text-transform: uppercase;
    letter-spacing: 0.08em;
    color: var(--muted);
    margin: 0 0 0.6rem;
  }
  label {
    display: block;
    font-size: 0.75rem;
    text-transform: uppercase;
    margin-bottom: 0.25rem;
    color: var(--muted);
  }
  textarea, input, select {
    width: 100%;
    background: #021016;
    border: 1px solid #163445;
    border-radius: 10px;
    color: var(--fg);
    padding: 0.6rem 0.7rem;
    font-family: inherit;
    font-size: 0.86rem;
    resize: vertical;
  }
  textarea:focus, input:focus, select:focus {
    outline: 1px solid var(--accent2);
    border-color: var(--accent2);
  }
  button {
    background: var(--accent);
    color: #041b26;
    border: none;
    border-radius: 999px;
    padding: 0.45rem 0.9rem;
    font-size: 0.8rem;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 0.05em;
    cursor: pointer;
    transition: transform 0.05s ease, box-shadow 0.1s ease, background 0.15s ease;
    box-shadow: 0 4px 0 rgba(0,0,0,0.35);
  }
  button:hover {
    transform: translateY(-1px);
    box-shadow: 0 6px 0 rgba(0,0,0,0.45);
  }
  button:active {
    transform: translateY(1px);
    box-shadow: 0 1px 0 rgba(0,0,0,0.45);
  }
  button.secondary {
    background: #021016;
    color: var(--fg);
    border-radius: 999px;
    border: 1px solid #30475e;
    box-shadow: none;
  }
  /* danger defaults to neutral and shows red on hover */
  button.danger {
    background: transparent;
    color: var(--fg);
    border: 1px solid rgba(255,255,255,0.04);
  }
  button.danger:hover {
    background: var(--danger);
    color: #fff;
    border-color: var(--danger);
  }
  .row {
    display: flex;
    gap: 0.6rem;
    align-items: center;
    margin-top: 0.5rem;
  }
  .row.space-between {
    justify-content: space-between;
  }
  .jobs-list {
    max-height: 64vh;
    overflow-y: auto;
    margin-top: 0.3rem;
  }
  .job-item {
    display: flex;
    flex-direction: column;
    gap: 0.2rem;
    padding: 0.45rem 0.5rem;
    border-radius: 10px;
    background: rgba(2, 16, 22, 0.7);
    border: 1px solid rgba(255,255,255,0.03);
    margin-bottom: 0.3rem;
    cursor: pointer;
  }
  .job-item.selected { box-shadow: 0 0 0 2px rgba(0,192,163,0.12); background: rgba(0,192,163,0.05); }
  .job-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    gap: 0.4rem;
  }
  .status-pill {
    padding: 0.1rem 0.5rem;
    border-radius: 999px;
    font-size: 0.7rem;
    text-transform: uppercase;
    letter-spacing: 0.07em;
  }
  .status-queued { background: rgba(0,192,163,0.15); color: var(--accent2); }
  .status-running { background: rgba(0,170,255,0.12); color: #73d1ff; }
  .job-item.running { box-shadow: 0 0 8px rgba(115,209,255,0.12); position: relative; }
  .job-item.running::after { content: ""; position: absolute; left: 8px; top: 50%; transform: translateY(-50%); width:10px; height:10px; border-radius:50%; background: rgba(115,209,255,0.9); box-shadow: 0 0 8px rgba(115,209,255,0.8); animation: pulse 1.6s infinite; }
  @keyframes pulse { 0% { transform: translateY(-50%) scale(0.9); opacity:0.7 } 50% { transform: translateY(-50%) scale(1.1); opacity:1 } 100% { transform: translateY(-50%) scale(0.9); opacity:0.7 } }
  .status-success { background: rgba(0,192,163,0.2); color: #54f29b; }
  .status-failed  { background: rgba(255,75,92,0.2); color: #ff9aa6; }
  .job-actions {
    display: flex;
    flex-wrap: wrap;
    gap: 0.3rem;
  }
  .monospace {
    font-family: "JetBrains Mono", ui-monospace, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
  }
  #log-view {
    background: #021016;
    border-radius: 10px;
    padding: 0.6rem;
    font-size: 0.8rem;
    height: 36vh;
    overflow-y: auto;
    border: 1px solid #163445;
  }
  #log-view pre {
    margin: 0;
    white-space: pre-wrap;
  }
  .files-list { max-height: 36vh; overflow-y: auto; margin-top: 0.5rem; }
  /* files-area collapse animation (CSS-only slide down/up) */
  .files-area { overflow: hidden; }
  #files-area-inner { transition: max-height 260ms cubic-bezier(.25,.8,.25,1), opacity 240ms ease, transform 260ms cubic-bezier(.25,.8,.25,1); max-height: 0; opacity: 0; transform: translateY(-6px); }
  #files-area-inner.expanded { max-height: 800px; opacity: 1; transform: translateY(0); }
  .file-item { display:flex; justify-content:space-between; padding:0.4rem; border-radius:8px; background:rgba(2,16,22,0.6); margin-bottom:0.25rem; }
  .file-name { font-size:0.9rem; }
  .files-list a { color: var(--accent2); text-decoration: none; }
  .files-list a:visited { color: rgba(0,192,163,0.8); }

  /* console collapse animation */
  #console-area { overflow: hidden; }
  #console-inner { transition: max-height 260ms cubic-bezier(.25,.8,.25,1), opacity 200ms ease, transform 260ms cubic-bezier(.25,.8,.25,1); max-height: 0; opacity: 0; transform: translateY(-6px); }
  #console-inner.expanded { max-height: 800px; opacity: 1; transform: translateY(0); }
  footer {
    padding: 0.6rem 1.5rem;
    font-size: 0.7rem;
    color: var(--muted);
    display: flex;
    justify-content: space-between;
  }
</style>
</head>
<body>
<header>
  <div class="blob"></div>
  <div>Low Tide</div>
</header>

<main>
  <section class="card">
    <h2>New Download Job</h2>
    <form id="new-job-form">
      <label for="app">Downloader</label>
      <select id="app" name="app_id">
        <option value="auto">Auto-detect</option>
        {{range .}}
        <option value="{{.ID}}">{{.Name}}</option>
        {{end}}
      </select>

      <label for="urls">URLs (one per line or space-separated)</label>
      <textarea id="urls" name="urls" rows="4" placeholder="https://example.com/file1.mp3
https://example.com/file2.mp3"></textarea>

      <div class="row" style="justify-content: flex-end; margin-top: 0.8rem;">
        <button type="submit">Queue Job</button>
      </div>
    </form>
  </section>

  <section class="card" style="grid-column: 2;">
    <div style="display:flex; justify-content:space-between; align-items:center;">
      <h2 style="margin:0;">Jobs</h2>
      <div>
        <button class="secondary" id="toggle-archived">▸</button>
      </div>
    </div>
    <h3 style="color:var(--muted); margin:0.6rem 0 0.2rem 0;">Active</h3>
    <div class="jobs-list monospace" id="jobs-list"></div>

    <div id="archived-section" style="display:none; margin-top:0.8rem;">
      <h3 style="color:var(--muted); margin:0.6rem 0 0.2rem 0;">Archived</h3>
      <div class="jobs-list monospace" id="archived-list"></div>
    </div>
  </section>

  <!-- Chosen job status: spans full width underneath form + job list -->
  <section class="card" id="files-pane" style="display:none; grid-column: 1 / -1; margin-top: 1.2rem;">
    <div style="display:flex; justify-content:space-between; align-items:center;">
      <h2 style="margin:0;"><span id="files-job-title">(none)</span></h2>
      <!-- Close button removed as requested -->
    </div>

    <div style="margin-top:0.6rem; display:flex; gap:1.2rem; align-items:flex-start;">
      <div style="flex:1;">
        <div class="row" id="job-actions-row" style="margin-bottom:0.5rem;">
          <button class="secondary" id="action-retry" style="display:none;">Retry</button>
          <button class="secondary" id="action-download">Download ZIP</button>
          <button class="secondary" id="job-open-source" style="order:0;">Open original</button>
          <button class="secondary" id="action-archive">Archive</button>
          <button class="secondary danger" id="action-delete">Delete</button>
        </div>

        <div id="files-area" class="files-area">
          <div id="files-area-inner">
            <div class="files-list monospace" id="files-list"><em>Select a job to view files.</em></div>
          </div>
        </div>

      </div>

    </div>

    <div style="margin-top:1rem;">
      <div style="display:flex; justify-content:space-between; align-items:center;">
        <h3 style="margin:0 0 0.4rem 0; color:var(--muted);">Logs</h3>
        <div>
          <button class="secondary" id="toggle-console">Expand</button>
        </div>
      </div>
      <div id="console-area">
        <div id="console-inner">
          <div id="log-view" class="monospace"><pre id="log-pre">No job selected.</pre></div>
        </div>
      </div>
    </div>

  </section>
</main>

<footer>
  <span>One-at-a-time downloads</span>
  <span>Go · WebSocket · SQLite · 90s slime</span>
</footer>

<script>
  // GIANT OBJECT STATE
  const STATE = {
    jobs: {}, // Map<id, JobObject>
    // JobObject structure:
    // {
    //   ...metadata (id, status, title, etc),
    //   files: [],
    //   logs: [],
    //   logsFetchStatus: 'none' | 'fetching' | 'done',
    //   filesFetchStatus: 'none' | 'fetching' | 'done',
    //   dirty: false // if true, needs re-render in list
    // }
    selectedJobId: null,
    showArchived: false,
    consoleCollapsed: true,
  };

  let stateSocket = null;

  // --- RENDERING ---

  function render() {
    renderJobsLists();
    renderSelectedJobPane();
  }

  function renderJobsLists() {
    const activeList = document.getElementById('jobs-list');
    const archivedList = document.getElementById('archived-list');
    
    // Convert map to array and sort by created_at desc
    const allJobs = Object.values(STATE.jobs).sort((a, b) => new Date(b.created_at) - new Date(a.created_at));
    
    // We only re-render if we really need to, but for simplicity let's just clear and rebuild for now
    // A better approach in a real "React-like" system would be diffing, but we'll trust the browser is fast enough for <100 elements.
    // To minimize flickering, we can try to reuse elements, but let's start simple.
    
    activeList.innerHTML = '';
    archivedList.innerHTML = '';

    allJobs.forEach(job => {
      const el = createJobItem(job);
      if (job.archived) {
        archivedList.appendChild(el);
      } else {
        activeList.appendChild(el);
      }
    });
    
    const archivedSec = document.getElementById('archived-section');
    const toggleBtn = document.getElementById('toggle-archived');
    if (STATE.showArchived) {
      archivedSec.style.display = 'block';
      toggleBtn.textContent = '▾';
    } else {
      archivedSec.style.display = 'none';
      toggleBtn.textContent = '▸';
    }
  }
  
  function createJobItem(job) {
    const div = document.createElement('div');
    div.className = 'job-item';
    if (STATE.selectedJobId === job.id) div.classList.add('selected');
    if (job.status === 'running') div.classList.add('running');
    
    const header = document.createElement('div');
    header.className = 'job-header';
    
    const left = document.createElement('div');
    const title = job.title && job.title !== '' ? job.title : (job.url || job.original_url || 'Job #' + job.id);
    left.innerText = title;
    
    const status = document.createElement('div');
    status.className = 'status-pill status-' + job.status;
    status.textContent = job.status.toUpperCase();
    
    header.appendChild(left);
    header.appendChild(status);
    div.appendChild(header);
    
    div.onclick = () => selectJob(job.id);
    
    return div;
  }

  function renderSelectedJobPane() {
    const pane = document.getElementById('files-pane');
    if (!STATE.selectedJobId) {
      pane.style.display = 'none';
      return;
    }
    const job = STATE.jobs[STATE.selectedJobId];
    if (!job) {
      // Selected job might have been deleted/cleared
      pane.style.display = 'none';
      return;
    }
    
    pane.style.display = '';
    
    // Header
    const title = job.title && job.title !== '' ? job.title : (job.url || job.original_url || '#' + job.id);
    document.getElementById('files-job-title').textContent = title;
    
    // Actions
    updateJobActions(job);
    
    // Files
    renderFilesList(job);
    
    // Logs
    renderLogs(job);

    // Console collapse state
    const consoleInner = document.getElementById('console-inner');
    const toggleBtn = document.getElementById('toggle-console');
    if (STATE.consoleCollapsed) {
        consoleInner.classList.remove('expanded');
        toggleBtn.textContent = 'Expand';
    } else {
        consoleInner.classList.add('expanded');
        toggleBtn.textContent = 'Collapse';
    }
  }

  function renderFilesList(job) {
    const el = document.getElementById('files-list');
    const files = job.files || [];
    const filesAreaInner = document.getElementById('files-area-inner');
    
    if (files.length === 0) {
      el.innerHTML = '<em>No files recorded for this job.</em>';
      // If running, hide the area (it will pop open when files arrive)
      // If finished/failed, show it so they see "No files"
      if (job.status === 'running') {
          filesAreaInner.classList.remove('expanded');
      } else {
          filesAreaInner.classList.add('expanded');
      }
      return;
    }
    
    filesAreaInner.classList.add('expanded');
    
    // Generate HTML for files
    // (Using same logic as before: grouping by common prefix)
    el.innerHTML = '';
    
    if (files.length === 1) {
        const f = files[0];
        const row = document.createElement('div'); row.className = 'file-item';
        const left = document.createElement('div'); left.className = 'file-name';
        const basename = f.path.split('/').pop();
        left.innerHTML = `<a href='/api/jobs/${job.id}/files/${f.id}'>${basename}</a> <span style='color:var(--muted)'>(${humanSize(f.size_bytes)})</span>`;
        row.appendChild(left); el.appendChild(row);
        return;
    }
    
    const paths = files.map(f => f.path.split('/').slice(0, -1).join('/')); 
    const firstDir = paths[0];
    const allSameDir = paths.every(p => p === firstDir);
    
    let commonPrefix = '';
    if (allSameDir) {
        commonPrefix = firstDir;
    } else {
        const splitPaths = files.map(f => f.path.split('/').filter(x => x));
        if (splitPaths.length > 0) {
             let prefix = splitPaths[0].slice(0, -1);
             for (let i = 1; i < splitPaths.length; i++) {
                 const current = splitPaths[i];
                 let j = 0;
                 while (j < prefix.length && j < current.length - 1 && prefix[j] === current[j]) {
                     j++;
                 }
                 prefix = prefix.slice(0, j);
             }
             if (prefix.length > 0) commonPrefix = '/' + prefix.join('/');
        }
    }
    
    let displayPrefix = commonPrefix;
    if (displayPrefix === '/') displayPrefix = '';
    
    if (displayPrefix) {
        const hdr = document.createElement('div');
        hdr.style.fontWeight = '600'; 
        hdr.style.margin = '0.4rem 0 0.2rem 0';
        hdr.textContent = displayPrefix.replace(/^\//, ''); 
        el.appendChild(hdr);
    }
    
    files.forEach(f => {
        const row = document.createElement('div'); 
        row.className = 'file-item';
        if (displayPrefix) {
            row.style.paddingLeft = '1rem';
        }
        
        const left = document.createElement('div'); 
        left.className = 'file-name';
        let displayName = f.path.split('/').pop();
        
        left.innerHTML = `<a href='/api/jobs/${job.id}/files/${f.id}'>${displayName}</a> <span style='color:var(--muted)'>(${humanSize(f.size_bytes)})</span>`;
        row.appendChild(left); 
        el.appendChild(row);
    });
  }

  function renderLogs(job) {
      const pre = document.getElementById('log-pre');
      const logView = document.getElementById('log-view');
      
      // If we have logs in state, join them
      // NOTE: Logs might be incomplete if we haven't fetched them all yet.
      // But we are appending to logs array in handleStateMessage.
      
      if (!job.logs || job.logs.length === 0) {
          pre.textContent = 'No logs.';
      } else {
          // Optimization: Only update textContent if length changed significantly or completely different?
          // For now, just join.
          // To improve perf, we can store the "rendered text" in the job object too?
          // Or just be simple.
          pre.textContent = job.logs.map(l => l.line).join('\n');
      }
      
      // Auto-scroll if running
      if (job.status === 'running') {
         logView.scrollTop = logView.scrollHeight;
      }
  }

  function updateJobActions(job) {
    const actionDownload = document.getElementById('action-download');
    const actionRetry = document.getElementById('action-retry');
    const actionArchive = document.getElementById('action-archive');
    const openSource = document.getElementById('job-open-source');
    const fileCount = (job.files || []).length;
    
    if (fileCount === 0) {
      actionDownload.style.display = 'none';
    } else if (fileCount === 1) {
      actionDownload.style.display = '';
      actionDownload.textContent = 'Download';
      const f = job.files[0];
      actionDownload.onclick = () => { window.location = '/api/jobs/' + job.id + '/files/' + f.id; };
    } else {
      actionDownload.style.display = '';
      actionDownload.textContent = 'Download ZIP';
      actionDownload.onclick = () => { window.location = '/api/jobs/' + job.id + '/zip' };
    }
    
    if (job.status === 'failed') actionRetry.style.display = '';
    else actionRetry.style.display = 'none';
    
    if (job.archived) actionArchive.style.display = 'none';
    else actionArchive.style.display = '';
    
    if (job.original_url) {
      openSource.onclick = () => window.open(job.original_url, '_blank');
      openSource.style.display = '';
    } else {
      openSource.style.display = 'none';
    }
  }

  // --- ACTIONS ---

  async function loadInitialData() {
    try {
        const [activeRes, archivedRes, currentRes] = await Promise.all([
            fetch('/api/jobs'),
            fetch('/api/jobs?archived=1'),
            fetch('/api/current')
        ]);
        
        const active = await activeRes.json();
        const archived = await archivedRes.json();
        const currentData = await currentRes.json();
        
        // Populate giant object
        active.forEach(j => updateJobState(j));
        archived.forEach(j => updateJobState(j));
        
        // If there is a current running job, auto-select it if nothing else selected
        if (currentData.current_job && currentData.current_job !== 0) {
            selectJob(currentData.current_job);
        } else if (active.length > 0) {
            // Optional: select most recent? No, maybe don't select anything by default unless running.
        }
        
        render();
        connectWebSocket();
    } catch (e) {
        console.error('Initial load failed', e);
    }
  }

  async function selectJob(id) {
      if (STATE.selectedJobId === id) return; // already selected
      
      STATE.selectedJobId = id;
      
      // Auto-collapse based on status
      const job = STATE.jobs[id];
      if (job && job.status === 'success') {
          STATE.consoleCollapsed = true;
      } else {
          STATE.consoleCollapsed = false;
      }
      
      if (!job) return;

      // When selecting, we want to ensure we have the latest snapshot + logs
      // But we can render what we have immediately
      render();
      
      // Fetch full details (snapshot + logs)
      await fetchJobDetails(id);
  }

  async function fetchJobDetails(id) {
      // Fetch snapshot (includes files AND logs by default now)
      try {
          // skip_logs=0 is default logic if omitted, but being explicit is fine.
          // logic: !skipLogs -> fetch logs.
          const res = await fetch(`/api/jobs/${id}`);
          if (res.ok) {
              const data = await res.json();
              if (data.job) {
                  updateJobState(data.job, data.files, data.logs);
                  if (data.logs && STATE.selectedJobId === id) {
                      render(); // re-render logs
                  }
              }
          }
      } catch (e) { console.error(e); }
  }

  function updateJobState(jobData, filesData, logsData) {
      const id = jobData.id;
      if (!STATE.jobs[id]) {
          STATE.jobs[id] = { logs: [], files: [] };
      }
      
      // Merge metadata
      STATE.jobs[id] = { ...STATE.jobs[id], ...jobData };
      
      if (filesData) {
          STATE.jobs[id].files = filesData;
      }
      
      if (logsData) {
          STATE.jobs[id].logs = logsData;
      }
      
      // If status changed to running, ensure we are "watching" it? 
      // The websocket handles updates.
      render();
  }

  // --- WEBSOCKET ---

  function connectWebSocket() {
      const proto = location.protocol === 'https:' ? 'wss:' : 'ws:';
      stateSocket = new WebSocket(proto + '//' + location.host + '/ws/state');
      stateSocket.onmessage = (ev) => {
          try {
              const msg = JSON.parse(ev.data);
              handleWSMessage(msg);
          } catch (e) { console.error(e); }
      };
      stateSocket.onclose = () => setTimeout(connectWebSocket, 2000);
  }

  function handleWSMessage(msg) {
      if (msg.type === 'job_snapshot') {
          if (msg.job) {
              const oldStatus = STATE.jobs[msg.job.id] ? STATE.jobs[msg.job.id].status : null;
              updateJobState(msg.job, msg.files);
              
              // If this job is currently selected
              if (msg.job.id === STATE.selectedJobId) {
                  // If transitioning running -> success, collapse console
                  if (oldStatus === 'running' && msg.job.status === 'success') {
                      STATE.consoleCollapsed = true;
                      renderSelectedJobPane();
                  }
              } else if (msg.job.status === 'running') {
                  // If new running job, select it
                  selectJob(msg.job.id);
              }
          }
      } else if (msg.type === 'job_log') {
          const job = STATE.jobs[msg.job_id];
          if (job) {
              // Append log
              if (!job.logs) job.logs = [];
              job.logs.push({ line: msg.line, when: msg.when });
              
              // Only re-render if this is the selected job
              if (STATE.selectedJobId === msg.job_id) {
                  renderLogs(job);
              }
          }
      } else if (msg.type === 'jobs_archived') {
          // Reload everything to be safe
          loadInitialData();
      }
  }

  // --- EVENT HANDLERS ---
  
  document.getElementById('new-job-form').addEventListener('submit', async (ev) => {
      ev.preventDefault();
      const fd = new FormData(ev.target);
      const res = await fetch('/api/jobs', { method: 'POST', body: fd });
      if (res.ok) {
          ev.target.reset();
          const data = await res.json();
          // If a single job ID returned, we could select it.
          // But usually we wait for the WS snapshot which comes immediately.
      }
  });

  document.getElementById('toggle-archived').addEventListener('click', () => {
      STATE.showArchived = !STATE.showArchived;
      render();
  });
  
  document.getElementById('toggle-console').addEventListener('click', () => {
      STATE.consoleCollapsed = !STATE.consoleCollapsed;
      renderSelectedJobPane(); // re-renders console state
  });

  document.getElementById('action-retry').addEventListener('click', async () => {
      if (!STATE.selectedJobId) return;
      await fetch(`/api/jobs/${STATE.selectedJobId}/retry`, { method: 'POST' });
  });

  document.getElementById('action-archive').addEventListener('click', async () => {
      if (!STATE.selectedJobId) return;
      await fetch(`/api/jobs/${STATE.selectedJobId}/archive`, { method: 'POST' });
      // WS will send snapshot with archived=true
  });

  document.getElementById('action-delete').addEventListener('click', async () => {
      if (!STATE.selectedJobId) return;
      if (!confirm('Delete job? ⚠️ this will also delete the files')) return;
      const id = STATE.selectedJobId;
      await fetch(`/api/jobs/${id}/delete`, { method: 'POST' });
      // Delete locally
      delete STATE.jobs[id];
      STATE.selectedJobId = null;
      render();
  });
  
  // Helpers
  function humanSize(bytes) {
    if (!bytes && bytes !== 0) return '';
    const b = Number(bytes);
    if (b < 1024) return b + ' B';
    const kb = b / 1024;
    if (kb < 1024) return Math.round(kb) + ' KB';
    const mb = kb / 1024;
    if (mb < 1024) return Math.round(mb) + ' MB';
    const gb = mb / 1024;
    return Math.round(gb) + ' GB';
  }

  // Boot
  loadInitialData();

</script>
</body>
</html>
