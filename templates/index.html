<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Low Tide</title>
<style>
  :root {
    --bg: #041b26;
    --fg: #fef4e3;
    --accent: #ff7f1f;
    --accent2: #00c0a3;
    --muted: #5c6f82;
    --card-bg: #0c2835;
    --danger: #ff4b5c;
  }
  * { box-sizing: border-box; }
  body {
    margin: 0;
    font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    background: var(--bg);
    color: var(--fg);
    display: flex;
    flex-direction: column;
    min-height: 100vh;
  }
  header {
    padding: 1rem 1.5rem;
    background: linear-gradient(90deg, #ff7f1f, #ffca1f);
    color: #041b26;
    font-weight: 800;
    letter-spacing: 0.06em;
    text-transform: uppercase;
    display: flex;
    align-items: center;
    gap: 0.75rem;
    box-shadow: 0 0 20px rgba(255, 127, 31, 0.4);
  }
  header .blob {
    width: 32px;
    height: 32px;
    background: #041b26;
    border-radius: 60% 40% 40% 70% / 50% 60% 40% 50%;
  }
  main {
    flex: 1;
    padding: 1.5rem;
    max-width: 1400px;
    margin: 0 auto;
    display: grid;
    grid-template-columns: 1fr 2fr;
    gap: 1.2rem;
    align-items: start;
  }
  .card {
    background: var(--card-bg);
    border-radius: 14px;
    padding: 1rem 1.2rem;
    box-shadow: 0 0 0 1px rgba(255,255,255,0.02), 0 14px 30px rgba(0,0,0,0.45);
  }
  h2 {
    font-size: 0.95rem;
    text-transform: uppercase;
    letter-spacing: 0.08em;
    color: var(--muted);
    margin: 0 0 0.6rem;
  }
  label {
    display: block;
    font-size: 0.75rem;
    text-transform: uppercase;
    margin-bottom: 0.25rem;
    color: var(--muted);
  }
  textarea, input, select {
    width: 100%;
    background: #021016;
    border: 1px solid #163445;
    border-radius: 10px;
    color: var(--fg);
    padding: 0.6rem 0.7rem;
    font-family: inherit;
    font-size: 0.86rem;
    resize: vertical;
  }
  textarea:focus, input:focus, select:focus {
    outline: 1px solid var(--accent2);
    border-color: var(--accent2);
  }
  button {
    background: var(--accent);
    color: #041b26;
    border: none;
    border-radius: 999px;
    padding: 0.45rem 0.9rem;
    font-size: 0.8rem;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 0.05em;
    cursor: pointer;
    transition: transform 0.05s ease, box-shadow 0.1s ease, background 0.15s ease;
    box-shadow: 0 4px 0 rgba(0,0,0,0.35);
  }
  button:hover {
    transform: translateY(-1px);
    box-shadow: 0 6px 0 rgba(0,0,0,0.45);
  }
  button:active {
    transform: translateY(1px);
    box-shadow: 0 1px 0 rgba(0,0,0,0.45);
  }
  button.secondary {
    background: #021016;
    color: var(--fg);
    border-radius: 999px;
    border: 1px solid #30475e;
    box-shadow: none;
  }
  /* danger defaults to neutral and shows red on hover */
  button.danger {
    background: transparent;
    color: var(--fg);
    border: 1px solid rgba(255,255,255,0.04);
  }
  button.danger:hover {
    background: var(--danger);
    color: #fff;
    border-color: var(--danger);
  }
  .row {
    display: flex;
    gap: 0.6rem;
    align-items: center;
    margin-top: 0.5rem;
  }
  .row.space-between {
    justify-content: space-between;
  }
  .jobs-list {
    max-height: 64vh;
    overflow-y: auto;
    margin-top: 0.3rem;
  }
  .job-item {
    display: flex;
    flex-direction: column;
    gap: 0.2rem;
    padding: 0.45rem 0.5rem;
    border-radius: 10px;
    background: rgba(2, 16, 22, 0.7);
    border: 1px solid rgba(255,255,255,0.03);
    margin-bottom: 0.3rem;
    cursor: pointer;
  }
  .job-item.selected { box-shadow: 0 0 0 2px rgba(0,192,163,0.12); }
  .job-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    gap: 0.4rem;
  }
  .status-pill {
    padding: 0.1rem 0.5rem;
    border-radius: 999px;
    font-size: 0.7rem;
    text-transform: uppercase;
    letter-spacing: 0.07em;
  }
  .status-queued { background: rgba(0,192,163,0.15); color: var(--accent2); }
  .status-running { background: rgba(0,170,255,0.12); color: #73d1ff; }
  .job-item.running { box-shadow: 0 0 8px rgba(115,209,255,0.12); position: relative; }
  .job-item.running::after { content: ""; position: absolute; left: 8px; top: 50%; transform: translateY(-50%); width:10px; height:10px; border-radius:50%; background: rgba(115,209,255,0.9); box-shadow: 0 0 8px rgba(115,209,255,0.8); animation: pulse 1.6s infinite; }
  @keyframes pulse { 0% { transform: translateY(-50%) scale(0.9); opacity:0.7 } 50% { transform: translateY(-50%) scale(1.1); opacity:1 } 100% { transform: translateY(-50%) scale(0.9); opacity:0.7 } }
  .status-success { background: rgba(0,192,163,0.2); color: #54f29b; }
  .status-failed  { background: rgba(255,75,92,0.2); color: #ff9aa6; }
  .job-actions {
    display: flex;
    flex-wrap: wrap;
    gap: 0.3rem;
  }
  .monospace {
    font-family: "JetBrains Mono", ui-monospace, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
  }
  #log-view {
    background: #021016;
    border-radius: 10px;
    padding: 0.6rem;
    font-size: 0.8rem;
    height: 36vh;
    overflow-y: auto;
    border: 1px solid #163445;
  }
  #log-view pre {
    margin: 0;
    white-space: pre-wrap;
  }
  .files-list { max-height: 36vh; overflow-y: auto; margin-top: 0.5rem; }
  /* files-area collapse animation (CSS-only slide down/up) */
  .files-area { overflow: hidden; }
  #files-area-inner { transition: max-height 260ms cubic-bezier(.25,.8,.25,1), opacity 240ms ease, transform 260ms cubic-bezier(.25,.8,.25,1); max-height: 0; opacity: 0; transform: translateY(-6px); }
  #files-area-inner.expanded { max-height: 800px; opacity: 1; transform: translateY(0); }
  .file-item { display:flex; justify-content:space-between; padding:0.4rem; border-radius:8px; background:rgba(2,16,22,0.6); margin-bottom:0.25rem; }
  .file-name { font-size:0.9rem; }
  .files-list a { color: var(--accent2); text-decoration: none; }
  .files-list a:visited { color: rgba(0,192,163,0.8); }

  /* console collapse animation */
  #console-area { overflow: hidden; }
  #console-inner { transition: max-height 260ms cubic-bezier(.25,.8,.25,1), opacity 200ms ease, transform 260ms cubic-bezier(.25,.8,.25,1); max-height: 0; opacity: 0; transform: translateY(-6px); }
  #console-inner.expanded { max-height: 800px; opacity: 1; transform: translateY(0); }
  footer {
    padding: 0.6rem 1.5rem;
    font-size: 0.7rem;
    color: var(--muted);
    display: flex;
    justify-content: space-between;
  }
</style>
</head>
<body>
<header>
  <div class="blob"></div>
  <div>Low Tide</div>
</header>

<main>
  <section class="card">
    <h2>New Download Job</h2>
    <form id="new-job-form">
      <label for="app">Downloader</label>
      <select id="app" name="app_id"></select>

      <label for="urls">URLs (one per line or space-separated)</label>
      <textarea id="urls" name="urls" rows="4" placeholder="https://example.com/file1.mp3
https://example.com/file2.mp3"></textarea>

      <div class="row" style="justify-content: flex-end; margin-top: 0.8rem;">
        <button type="submit">Queue Job</button>
      </div>
    </form>
  </section>

  <section class="card" style="grid-column: 2;">
    <div style="display:flex; justify-content:space-between; align-items:center;">
      <h2 style="margin:0;">Jobs</h2>
      <div>
        <button class="secondary" id="toggle-archived">▸</button>
      </div>
    </div>
    <h3 style="color:var(--muted); margin:0.6rem 0 0.2rem 0;">Active</h3>
    <div class="jobs-list monospace" id="jobs-list"></div>

    <div id="archived-section" style="display:none; margin-top:0.8rem;">
      <h3 style="color:var(--muted); margin:0.6rem 0 0.2rem 0;">Archived</h3>
      <div class="jobs-list monospace" id="archived-list"></div>
    </div>
  </section>

  <!-- Chosen job status: spans full width underneath form + job list -->
  <section class="card" id="files-pane" style="display:none; grid-column: 1 / -1; margin-top: 1.2rem;">
    <div style="display:flex; justify-content:space-between; align-items:center;">
      <h2 style="margin:0;">Job <span id="files-job-title">(none)</span></h2>
      <div>
        <button class="secondary" id="close-files-btn">Close</button>
      </div>
    </div>

    <div style="margin-top:0.6rem; display:flex; gap:1.2rem; align-items:flex-start;">
      <div style="flex:1;">
        <div class="row" id="job-actions-row" style="margin-bottom:0.5rem;">
          <button class="secondary" id="action-retry" style="display:none;">Retry</button>
          <button class="secondary" id="action-download">Download ZIP</button>
          <button class="secondary" id="job-open-source" style="order:0;">Open origin</button>
          <button class="secondary" id="action-archive">Archive</button>
          <button class="secondary danger" id="action-delete">Delete</button>
        </div>

        <div id="files-area" class="files-area">
          <div id="files-area-inner">
            <h3 style="margin:0 0 0.4rem 0; color:var(--muted);">Files</h3>
            <div class="files-list monospace" id="files-list"><em>Select a job to view files.</em></div>
          </div>
        </div>

      </div>

    </div>

    <div style="margin-top:1rem;">
      <div style="display:flex; justify-content:space-between; align-items:center;">
        <h3 style="margin:0 0 0.4rem 0; color:var(--muted);">Logs</h3>
        <div>
          <button class="secondary" id="toggle-console">Expand</button>
        </div>
      </div>
      <div id="console-area">
        <div id="console-inner">
          <div id="log-view" class="monospace"><pre id="log-pre">No job selected.</pre></div>
        </div>
      </div>
    </div>

  </section>
</main>

<footer>
  <span>One-at-a-time downloads</span>
  <span>Go · WebSocket · SQLite · 90s slime</span>
</footer>

<script>
  let stateSocket = null;
  let selectedJob = null; // user-selected pinned job
  let pinned = false;

  async function fetchState() {
    try {
      const [jobsRes, archivedRes, appsRes] = await Promise.all([
        fetch('/api/jobs'),
        fetch('/api/jobs?archived=1'),
        fetch('/api/apps'),
      ]);
      const jobs = await jobsRes.json();
      const archived = await archivedRes.json();
      const apps = await appsRes.json();
      renderApps(apps);
      renderJobs('jobs-list', jobs);
      renderJobs('archived-list', archived, true);

      // keep selection updated
      if (selectedJob) {
        const all = jobs.concat(archived);
        const found = all.find(j => j.id === selectedJob.id);
        if (found) {
          selectedJob = found;
          document.getElementById('files-job-title').textContent = selectedJob.title || ('#' + selectedJob.id);
        } else {
          // if archived/removed, clear selection
          selectedJob = null;
          pinned = false;
          hideFilesPane();
        }
      }
    } catch (err) {
      console.error('fetchState', err);
    }
  }

  function initStateSocket() {
    const proto = location.protocol === 'https:' ? 'wss:' : 'ws:';
    const ws = new WebSocket(proto + '//' + location.host + '/ws/state');
    stateSocket = ws;
    ws.onmessage = (ev) => {
      try {
        const msg = JSON.parse(ev.data);
        handleStateMessage(msg);
      } catch (e) {
        console.error('state ws parse', e);
      }
    };
    ws.onclose = () => {
      // reconnect with backoff
      stateSocket = null;
      setTimeout(initStateSocket, 2000);
    };
  }

  let consoleCollapsed = true; // default collapsed
  let fetchFilesDebounce = null;

  function scheduleFetchJobFiles(jobId) {
    if (fetchFilesDebounce) clearTimeout(fetchFilesDebounce);
    fetchFilesDebounce = setTimeout(() => { fetchJobFiles(jobId); fetchFilesDebounce = null }, 250);
  }

  async function handleStateMessage(msg) {
    if (!msg || !msg.type) return;
    const pre = document.getElementById('log-pre');
    
    switch (msg.type) {
      case 'job_snapshot':
        // Full update for a job: metadata, files, status
        if (!msg.job) return;
        
        // Update the job in the list directly if present
        // Only fetch state if job is new or if status changed in a way that might reorder lists
        // (e.g. archiving, but archiving has its own event)
        // For now, let's avoid fetchState entirely on snapshot and rely on DOM patching
        // or simply updating the specific item if found.
        const existingItem = document.querySelectorAll('.job-item');
        let found = false;
        // This is tricky without a data model. Let's try to update the status pill if found.
        // Or simpler: Check if we REALLY need to fetch.
        // If the job ID is known and status hasn't changed from what we have locally (if we tracked it), no fetch.
        // But we don't track all jobs locally in a map.
        
        // COMPROMISE: debounced fetchState. If snapshots come in fast, we only fetch once every 2s.
        // BETTER: Do not fetchState on snapshot. Snapshot IS the state for that job.

        // If selected, update details
        if (selectedJob && selectedJob.id === msg.job.id) {
          // Update local ref
          selectedJob = msg.job;
          document.getElementById('files-job-title').textContent = selectedJob.title || ('#' + selectedJob.id);
          
          // Files
          const files = msg.files || [];
          renderFilesList(msg.job.id, files);
          
          const filesAreaInner = document.getElementById('files-area-inner');
          if (files.length > 0) {
            filesAreaInner.classList.add('expanded');
          } else if (msg.job.status === 'running') {
            filesAreaInner.classList.remove('expanded');
          }

          // Auto-collapse console on success
          if (msg.job.status === 'success') {
            collapseConsole();
          } else if (msg.job.status === 'running' || msg.job.status === 'failed') {
            expandConsole();
          }
          
          updateJobActions(selectedJob, files.length);
        }

        // Update the job item in the list if it exists
        // We need to iterate or find the specific job item.
        // Ideally job items should have an ID.
        // Let's assume we can re-render the list item if we had the list data.
        // Since we don't have a global jobs list variable (it's inside fetchState), 
        // we can't easily patch the list without fetching.
        
        // CHANGE: Add ID to job-item divs in renderJobs so we can find them.
        // Then patch the status/title.
        const jobItem = document.getElementById('job-item-' + msg.job.id);
        if (jobItem) {
            // Update status class and text
            const statusPill = jobItem.querySelector('.status-pill');
            if (statusPill) {
                statusPill.className = 'status-pill status-' + msg.job.status;
                statusPill.textContent = msg.job.status.toUpperCase();
            }
            // Update title/app if needed (rarely changes)
            const titleDiv = jobItem.querySelector('.job-header > div:first-child');
            if (titleDiv) {
                 const title = msg.job.title && msg.job.title !== '' ? msg.job.title : (msg.job.urls || []).join(' ');
                 titleDiv.innerHTML = `${msg.job.app_id} &middot; ${title}`;
            }
            // Running state animation
            if (msg.job.status === 'running') jobItem.classList.add('running');
            else jobItem.classList.remove('running');
            
            // Update click handler closure? No, id is same.
            jobItem.onclick = () => selectJob(msg.job);
        } else {
            // New job? If status is queued, we might want to fetch to show it.
            // Or if we are viewing the list.
            if (msg.job.status === 'queued') scheduleFetchState();
        }

        // Auto-select rules
        if (msg.job.status === 'queued') {
            if (!pinned && !selectedJob) {
               selectJob(msg.job);
            }
        }
        
        // If a job started running and user hasn't pinned a job, show its logs
        if (!pinned && msg.job.status === 'running') {
            if (!selectedJob || selectedJob.id !== msg.job.id) {
                selectJob(msg.job, false);
            }
        }
        break;

      case 'jobs_archived':
        await fetchState();
        break;
        
      case 'job_log':
        // Append log line if this job is selected
        if (selectedJob && selectedJob.id === msg.job_id) {
           pre.textContent += msg.line + "\n";
           const logView = document.getElementById('log-view');
           logView.scrollTop = logView.scrollHeight;
        }
        break;

      default:
        // ignore unknown
    }
  }

  let fetchStateDebounce = null;
  function scheduleFetchState() {
      if (fetchStateDebounce) return;
      fetchStateDebounce = setTimeout(() => { fetchState(); fetchStateDebounce = null; }, 1000);
  }

  function collapseConsole() {
    const inner = document.getElementById('console-inner');
    if (inner) inner.classList.remove('expanded');
    document.getElementById('toggle-console').textContent = 'Expand';
    consoleCollapsed = true;
  }
  function expandConsole() {
    const inner = document.getElementById('console-inner');
    if (inner) inner.classList.add('expanded');
    document.getElementById('toggle-console').textContent = 'Collapse';
    consoleCollapsed = false;
  }

  document.getElementById('toggle-console').addEventListener('click', () => {
    if (consoleCollapsed) expandConsole(); else collapseConsole();
  });

  function humanSize(bytes) {
    if (!bytes && bytes !== 0) return '';
    const b = Number(bytes);
    if (b < 1024) return b + ' B';
    const kb = b / 1024;
    if (kb < 1024) return Math.round(kb) + ' KB';
    const mb = kb / 1024;
    if (mb < 1024) return Math.round(mb) + ' MB';
    const gb = mb / 1024;
    return Math.round(gb) + ' GB';
  }

  function renderApps(apps) {
    const sel = document.getElementById('app');
    sel.innerHTML = '';
    apps.forEach(a => {
      const opt = document.createElement('option');
      opt.value = a.id;
      opt.textContent = a.name;
      sel.appendChild(opt);
    });
  }

  function renderJobs(targetId, jobs, archived) {
    const el = document.getElementById(targetId);
    el.innerHTML = '';
    jobs.forEach(job => {
      const div = document.createElement('div');
      div.className = 'job-item';
      div.id = 'job-item-' + job.id; // Add ID for direct updates
      if (selectedJob && job.id === selectedJob.id) div.classList.add('selected');
      if (job.status === 'running') div.classList.add('running');

      const header = document.createElement('div');
      header.className = 'job-header';

      const left = document.createElement('div');
      const title = job.title && job.title !== '' ? job.title : (job.urls || []).join(' ');
      left.innerHTML = `${job.app_id}</span> &middot; ${title}`;
      header.appendChild(left);

      const status = document.createElement('div');
      status.className = 'status-pill status-' + job.status;
      status.textContent = job.status.toUpperCase();
      header.appendChild(status);
      div.appendChild(header);

      // Minimal clickable job item (actions moved to JOB ACTIONS pane)
      div.onclick = () => selectJob(job);
      el.appendChild(div);
    });
  }

  async function archiveJob(id) {
    // archive without confirmation
    await fetch('/api/jobs/' + id + '/archive', {method: 'POST'});
    await fetchState();
    if (selectedJob && selectedJob.id === id) {
      selectedJob = null; pinned = false; hideFilesPane();
    }
  }

  async function selectJob(job, doPin = true) {
    selectedJob = job;
    pinned = !!doPin;
    showFilesPane();
    document.getElementById('files-job-title').textContent = job.title || ('#' + job.id);
    await fetchJobFiles(job.id);
    await fetchJobLogs(job.id);
    // Ensure console is open for running or failed jobs
    if (job && job.status === 'running') expandConsole();
    // Open console for failed jobs too, as requested
    if (job && job.status === 'failed') expandConsole();
  }

  function showFilesPane() {
    document.getElementById('files-pane').style.display = '';
  }
  function hideFilesPane() {
    document.getElementById('files-pane').style.display = 'none';
    document.getElementById('files-list').innerHTML = '<em>Select a job to view files.</em>';
    const pre = document.getElementById('log-pre');
    if (pre) pre.textContent = 'No job selected.';
  }

  async function fetchJobFiles(id) {
    if (!id) return;
    try {
      const res = await fetch('/api/jobs/' + id + '/files');
      if (!res.ok) {
        document.getElementById('files-list').innerHTML = '<em>No files.</em>';
        document.getElementById('action-download').style.display = 'none';
        // collapse files area
        document.getElementById('files-area-inner').classList.remove('expanded');
        return;
      }
      const data = await res.json();

      const files = data.files || [];
      const total = files.length;

      // Files area visibility rules:
      // - If job is running and total==0 -> hide files area (it will expand when first file appears)
      // - If job failed and total==0 -> show empty state message
      // - Otherwise show files area expanded
      const filesAreaInner = document.getElementById('files-area-inner');
      if (selectedJob && selectedJob.status === 'running' && total === 0) {
        // hide
        filesAreaInner.classList.remove('expanded');
      } else {
        // show
        filesAreaInner.classList.add('expanded');
      }

      renderFilesList(id, files);
      updateJobActions(selectedJob, total);
    } catch (err) {
      console.error('fetchJobFiles', err);
    }
  }

  async function fetchJobLogs(id) {
    if (!id) return;
    try {
      const res = await fetch('/api/jobs/' + id + '/logs');
      if (!res.ok) return;
      const data = await res.json();
      const pre = document.getElementById('log-pre');
      pre.textContent = '';
      if (data.logs && Array.isArray(data.logs)) {
        data.logs.forEach(l => { pre.textContent += l.line + '
      }
    } catch (err) {
      console.error('fetchJobLogs', err);
    }
  }

  function updateJobActions(job, fileCount) {
      if (!job) return;
      const actionDownload = document.getElementById('action-download');
      const actionRetry = document.getElementById('action-retry');
      const actionArchive = document.getElementById('action-archive');
      const openSource = document.getElementById('job-open-source');
      
      if (fileCount === 0) {
        actionDownload.style.display = 'none';
      } else if (fileCount === 1) {
        actionDownload.style.display = '';
        actionDownload.textContent = 'Download';
        actionDownload.onclick = () => { fetch('/api/jobs/' + job.id + '/files').then(r=>r.json()).then(d=>{ if(d.files && d.files[0]) window.location = '/api/jobs/' + job.id + '/files/' + d.files[0].id; }) };
      } else {
        actionDownload.style.display = '';
        actionDownload.textContent = 'Download ZIP';
        actionDownload.onclick = () => { window.location = '/api/jobs/' + job.id + '/zip' };
      }
      
      if (job.status === 'failed') actionRetry.style.display = '';
      else actionRetry.style.display = 'none';
      
      if (job.archived) actionArchive.style.display = 'none';
      else actionArchive.style.display = '';
      
      if (job.original_url) {
        openSource.onclick = () => window.open(job.original_url, '_blank');
        openSource.style.display = '';
      } else {
        openSource.style.display = 'none';
      }
  }

  function renderFilesList(jobId, files) {
    const el = document.getElementById('files-list');
    el.innerHTML = '';
    if (!files || files.length === 0) { 
      el.innerHTML = '<em>No files recorded for this job.</em>';
      document.getElementById('action-download').style.display = 'none';
      return;
    }
    
    // Grouping logic:
    // 1. If only 1 file, show it directly (basename) without header.
    // 2. If multiple files: 
    //    a. Find common folder prefix. 
    //    b. If prefix is root or empty, list files.
    //    c. List files relative to that prefix.
    
    if (files.length === 1) {
        const f = files[0];
        const row = document.createElement('div'); row.className = 'file-item';
        const left = document.createElement('div'); left.className = 'file-name';
        const basename = f.path.split('/').pop();
        left.innerHTML = `<a href='/api/jobs/${jobId}/files/${f.id}'>${basename}</a> <span style='color:var(--muted)'>(${humanSize(f.size_bytes)})</span>`;
        row.appendChild(left); el.appendChild(row);
        return;
    }
    
    // Find common directory prefix
    // All paths start with /
    // /Albums/Artist/Song1.flac
    // /Albums/Artist/Song2.flac
    // Common dir: /Albums/Artist
    
    const paths = files.map(f => f.path.split('/').slice(0, -1).join('/')); // get dirs
    
    // Check if all files are in the SAME directory
    const firstDir = paths[0];
    const allSameDir = paths.every(p => p === firstDir);
    
    let commonPrefix = '';
    if (allSameDir) {
        commonPrefix = firstDir;
    } else {
        // If mixed directories, find common ancestor
        const splitPaths = files.map(f => f.path.split('/').filter(x => x));
        if (splitPaths.length > 0) {
             let prefix = splitPaths[0].slice(0, -1); // start with dir of first file
             for (let i = 1; i < splitPaths.length; i++) {
                 const current = splitPaths[i];
                 let j = 0;
                 while (j < prefix.length && j < current.length - 1 && prefix[j] === current[j]) {
                     j++;
                 }
                 prefix = prefix.slice(0, j);
             }
             if (prefix.length > 0) commonPrefix = '/' + prefix.join('/');
        }
    }
    
    
    let displayPrefix = commonPrefix;
    if (displayPrefix === '/') displayPrefix = ''; // Don't show '/' as header
    
    if (displayPrefix) {
        const hdr = document.createElement('div');
        hdr.style.fontWeight = '600'; 
        hdr.style.margin = '0.4rem 0 0.2rem 0';
        // e.g. /Albums/AlbumName -> Albums/AlbumName
        hdr.textContent = displayPrefix.replace(/^\//, ''); 
        el.appendChild(hdr);
    }
    
    files.forEach(f => {
        const row = document.createElement('div'); 
        row.className = 'file-item';
        // Indent if we have a header
        if (displayPrefix) {
            row.style.paddingLeft = '1rem';
        }
        
        const left = document.createElement('div'); 
        left.className = 'file-name';
        // Show basename if it's inside the common prefix, or full relative path if deeper?
        // Simple: Just show basename if we are in the common dir, otherwise relative
        let displayName = f.path.split('/').pop();
        if (displayPrefix && !f.path.startsWith(displayPrefix + '/')) {
            // should not happen if common prefix logic is correct for all files
            displayName = f.path.split('/').pop();
        }
        
        left.innerHTML = `<a href='/api/jobs/${jobId}/files/${f.id}'>${displayName}</a> <span style='color:var(--muted)'>(${humanSize(f.size_bytes)})</span>`;
        row.appendChild(left); 
        el.appendChild(row);
    });
  }

  async function retryJob(id) {
    await fetch('/api/jobs/' + id + '/retry', {method: 'POST'});
    // immediate refresh
    await fetchState();
  }

  async function deleteJobFiles(id) {
    if (!confirm('Delete files for job #' + id + '?')) return;
    await fetch('/api/jobs/' + id + '/files', {method: 'DELETE'});
    await fetchState();
    if (selectedJob && selectedJob.id === id) fetchJobFiles(id);
  }

  async function clearJobs() {
    await fetch('/api/jobs/clear', {method: 'POST'});
    await fetchState();
  }

  document.getElementById('new-job-form').addEventListener('submit', async (ev) => {
    ev.preventDefault();
    const form = ev.target;
    const fd = new FormData(form);
    const resp = await fetch('/api/jobs', { method: 'POST', body: fd });
    const data = await resp.json().catch(() => null);
    form.reset();
    
    // If no job is currently selected or running, select the new one
    if (data && (data.id || (data.ids && data.ids[0]))) {
        let newId = data.id || data.ids[0];
        // We don't have the job object yet, but we can wait for the snapshot or fetch it.
    }
    await fetchState();
    // If a job was created and there's no running job, auto-select the created job
    try {
      if (data) {
        let id = data.id || (data.ids && data.ids[0]);
        if (id) {
          // fetch jobs list to find the job object
          const r = await fetch('/api/jobs');
          const jobs = await r.json();
          const found = jobs.find(j => j.id === id);
          // Always select the new job if nothing is running, even if something else was selected
          // Actually, if a job is running, we might NOT want to switch.
          // Requirement: "if there's no job already running, switch to it"
          const anyRunning = jobs.some(j => j.status === 'running');
          if (found && !anyRunning) {
            selectJob(found);
          }
        }
      }
    } catch (e) {
      // ignore
    }
  });

  // Actions in JOB ACTIONS pane handle download/archive/retry/delete
  document.getElementById('action-download').addEventListener('click', () => { if (selectedJob) window.location = '/api/jobs/' + selectedJob.id + '/zip'; });
  document.getElementById('action-archive').addEventListener('click', async () => { if (selectedJob) await fetch('/api/jobs/' + selectedJob.id + '/archive', {method: 'POST'}); await fetchState(); });
  document.getElementById('action-retry').addEventListener('click', async () => { if (selectedJob) await retryJob(selectedJob.id); });
  document.getElementById('action-delete').addEventListener('click', async () => { if (!selectedJob) return; if (!confirm('Delete job #' + selectedJob.id + ' (archive + delete files)?')) return; await fetch('/api/jobs/' + selectedJob.id + '/delete', {method: 'POST'}); await fetchState(); selectedJob = null; pinned = false; hideFilesPane(); });
  // Wire UI controls
  document.getElementById('close-files-btn').addEventListener('click', () => {
    // unpin selection and revert to current running logs
    selectedJob = null;
    pinned = false;
    hideFilesPane();
    fetchCurrentAndShowLogs();
  });

  document.getElementById('toggle-archived').addEventListener('click', (ev) => {
    const sec = document.getElementById('archived-section');
    const btn = document.getElementById('toggle-archived');
    if (sec.style.display === 'none' || sec.style.display === '') {
      sec.style.display = '';
      btn.textContent = '▾';
    } else {
      sec.style.display = 'none';
      btn.textContent = '▸';
    }
  });

  // Initialize: fetch state and start state websocket for live updates
  async function start() {
    await fetchState();
    initStateSocket();
    // show logs for current running job by default or if we just reloaded page
    await fetchCurrentAndShowLogs();
  }

  async function fetchCurrentAndShowLogs() {
    try {
      const r = await fetch('/api/current');
      if (!r.ok) return;
      const d = await r.json();
      if (d.current_job && d.current_job !== 0) {
        if (!pinned) {
            // Auto-select running job
            const r2 = await fetch('/api/jobs');
            const jobs = await r2.json();
            const found = jobs.find(j => j.id === d.current_job);
            if (found) selectJob(found, false);
        }
      } else {
        // no current job
        if (!pinned) {
          const pre = document.getElementById('log-pre');
          pre.textContent = 'No job selected.';
        }
      }
    } catch (e) {
      console.error('fetchCurrent', e);
    }
  }

  start();
</script>
</body>
</html>
